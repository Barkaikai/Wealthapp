/*
WealthForge Backend
- Express server implementing endpoints expected by frontend (WealthForgeApp.jsx)
- Uses Sequelize ORM with SQLite for local demo and Postgres in production (configure via DATABASE_URL)
- Endpoints:
  GET /api/leaderboard
  GET /api/vault/:wallet
  POST /api/mine  -- accepts { userPubkey, amount, paymentTxSig?, taskProof? }
  POST /api/redeem -- { wallet, itemId }

Security & minting:
- Uses @solana/web3.js and @solana/spl-token to mint tokens to user after verification
- Production-grade payment verification: fetches parsed transaction and inspects SystemProgram transfer to OWNER_SOL and exact lamports
- Prevents double spending by marking paymentTxSig as used

ENV variables expected:
- SOLANA_RPC_URL
- MINT_ADDRESS
- MINT_DECIMALS
- OWNER_SOL
- DATABASE_URL (optional; defaults to sqlite://./dev.sqlite)
- OWNER_KEYPAIR_PATH -> path to owner-keypair.json (mint authority)

Run:
- npm install
- node server.js
*/

import express from 'express';
import bodyParser from 'body-parser';
import dotenv from 'dotenv';
import fs from 'fs';
import path from 'path';
import { Sequelize, DataTypes } from 'sequelize';
import { Connection, Keypair, PublicKey, clusterApiUrl } from '@solana/web3.js';
import { getOrCreateAssociatedTokenAccount, mintTo } from '@solana/spl-token';

dotenv.config();

const RPC = process.env.SOLANA_RPC_URL ?? clusterApiUrl('devnet');
const connection = new Connection(RPC, 'confirmed');

const OWNER_KEYPAIR_PATH = process.env.OWNER_KEYPAIR_PATH ?? './owner-keypair.json';
if (!fs.existsSync(OWNER_KEYPAIR_PATH)) {
  console.error('Missing owner keypair. Create owner-keypair.json and set OWNER_KEYPAIR_PATH if needed.');
  process.exit(1);
}
const ownerSecret = JSON.parse(fs.readFileSync(OWNER_KEYPAIR_PATH));
const ownerKeypair = Keypair.fromSecretKey(Uint8Array.from(ownerSecret));

const MINT_ADDRESS = new PublicKey(process.env.MINT_ADDRESS);
const MINT_DECIMALS = Number(process.env.MINT_DECIMALS ?? 6);
const OWNER_SOL = new PublicKey(process.env.OWNER_SOL);

// DATABASE
const DATABASE_URL = process.env.DATABASE_URL ?? `sqlite:${path.resolve('./dev.sqlite')}`;
const sequelize = new Sequelize(DATABASE_URL, { logging: false });

// Models
const User = sequelize.define('User', {
  wallet: { type: DataTypes.STRING, unique: true },
  nickname: { type: DataTypes.STRING },
  tokens_cached: { type: DataTypes.BIGINT, defaultValue: 0 }, // store minted smallest-units
});

const TaskProof = sequelize.define('TaskProof', {
  wallet: { type: DataTypes.STRING },
  proof: { type: DataTypes.JSON },
});

const MintLog = sequelize.define('MintLog', {
  wallet: { type: DataTypes.STRING },
  amount: { type: DataTypes.BIGINT }, // smallest units
  mintSig: { type: DataTypes.STRING },
  paymentTxSig: { type: DataTypes.STRING },
  taskProof: { type: DataTypes.JSON },
});

const UsedPayment = sequelize.define('UsedPayment', {
  txSig: { type: DataTypes.STRING, unique: true },
  wallet: { type: DataTypes.STRING },
  lamports: { type: DataTypes.BIGINT },
});

const VaultItem = sequelize.define('VaultItem', {
  itemId: { type: DataTypes.STRING, unique: true },
  name: { type: DataTypes.STRING },
  cost: { type: DataTypes.INTEGER },
  data: { type: DataTypes.JSON },
});

const UserVault = sequelize.define('UserVault', {
  wallet: { type: DataTypes.STRING },
  itemId: { type: DataTypes.STRING },
  redeemedAt: { type: DataTypes.DATE },
});

// Relations (optional)
User.hasMany(TaskProof, { foreignKey: 'wallet', sourceKey: 'wallet' });

async function initDb() {
  await sequelize.sync();
  // Seed some vault items if none
  const count = await VaultItem.count();
  if (count === 0) {
    await VaultItem.bulkCreate([
      { itemId: 'tmpl_starter', name: 'Starter Budget Template (PDF)', cost: 10, data: { url: '/assets/templates/starter.pdf' } },
      { itemId: 'mentor_15', name: '15-min Mentor Session (Voucher)', cost: 100, data: { details: 'Email to schedule' } },
    ]);
  }
}

// Helper: verify payment transaction is a SystemProgram transfer to OWNER_SOL and amount at least expected
async function verifyPaymentTx(txSig, expectedPayer, expectedRecipient, expectedLamports) {
  // fetch parsed transaction
  const parsed = await connection.getParsedTransaction(txSig, { commitment: 'confirmed' });
  if (!parsed) return { ok: false, reason: 'tx-not-found' };

  // Prevent re-use
  const used = await UsedPayment.findOne({ where: { txSig } });
  if (used) return { ok: false, reason: 'tx-already-used' };

  // check blockTime for recency if needed
  // verify accounts and parsed instructions
  const preBalances = parsed.meta.preBalances; // lamports array
  const postBalances = parsed.meta.postBalances;
  const accountKeys = parsed.transaction.message.accountKeys.map(k => ({ pubkey: k.pubkey.toString(), signer: k.signer, writable: k.writable }));

  // find recipient index
  const recipientStr = expectedRecipient.toBase58();
  const recipientIdx = accountKeys.findIndex(a => a.pubkey === recipientStr);
  if (recipientIdx === -1) return { ok: false, reason: 'recipient-not-present' };
  const delta = postBalances[recipientIdx] - preBalances[recipientIdx];
  if (delta < expectedLamports) return { ok: false, reason: 'insufficient-amount', delta };

  // check that payer is present and is signer
  const payerStr = expectedPayer;
  const payerIdx = accountKeys.findIndex(a => a.pubkey === payerStr);
  if (payerIdx === -1) return { ok: false, reason: 'payer-not-present' };
  if (!accountKeys[payerIdx].signer) return { ok: false, reason: 'payer-not-signer' };

  // optionally, ensure there's at least one transfer instruction in parsed.transaction.message.instructions
  // but change in balances is a robust check

  // mark used
  await UsedPayment.create({ txSig, wallet: payerStr, lamports: delta });
  return { ok: true, delta };
}

// Mint tokens to user's ATA
async function mintTokensToUser(userWalletStr, amountTokens) {
  const userPub = new PublicKey(userWalletStr);
  const destATA = await getOrCreateAssociatedTokenAccount(connection, ownerKeypair, MINT_ADDRESS, userPub);
  const mintAmount = BigInt(Math.floor(amountTokens * Math.pow(10, MINT_DECIMALS)));
  const sig = await mintTo(connection, ownerKeypair, MINT_ADDRESS, destATA.address, ownerKeypair, mintAmount);
  return { sig, mintedSmallest: mintAmount };
}

// Express app
const app = express();
app.use(bodyParser.json());

// GET leaderboard â€” compute from User.tokens_cached (convert smallest units back to token amount)
app.get('/api/leaderboard', async (req, res) => {
  try {
    const top = await User.findAll({ order: [['tokens_cached', 'DESC']], limit: 20 });
    const out = top.map(u => ({ wallet: u.wallet, nickname: u.nickname, tokens: Number(u.tokens_cached) / Math.pow(10, MINT_DECIMALS) }));
    res.json(out);
  } catch (err) { console.error(err); res.status(500).json({ error: err.message }); }
});

// GET vault items for a wallet
app.get('/api/vault/:wallet', async (req, res) => {
  try {
    const items = await VaultItem.findAll();
    res.json(items.map(i => ({ id: i.itemId, name: i.name, cost: i.cost, data: i.data })));
  } catch (err) { res.status(500).json({ error: err.message }); }
});

// POST redeem
app.post('/api/redeem', async (req, res) => {
  try {
    const { wallet, itemId } = req.body;
    if (!wallet || !itemId) return res.status(400).json({ error: 'missing' });
    const item = await VaultItem.findOne({ where: { itemId } });
    if (!item) return res.status(404).json({ error: 'not-found' });
    const user = await User.findOrCreate({ where: { wallet } });
    const u = user[0];
    // check user's cached token balance
    const userTokens = BigInt(u.tokens_cached);
    const costSmallest = BigInt(item.cost) * BigInt(Math.pow(10, MINT_DECIMALS));
    if (userTokens < costSmallest) return res.status(400).json({ error: 'insufficient-tokens' });
    // deduct
    u.tokens_cached = (userTokens - costSmallest).toString();
    await u.save();
    await UserVault.create({ wallet, itemId, redeemedAt: new Date() });
    res.json({ success: true, item: { id: item.itemId, name: item.name, data: item.data } });
  } catch (err) { console.error(err); res.status(500).json({ error: err.message }); }
});

// POST /api/mine
/*
Body: { userPubkey, amount, paymentTxSig?, taskProof? }
Flow:
 - Validate input
 - If paymentTxSig present: verify payment via verifyPaymentTx() ensuring transferred lamports >= price * amount
 - If free (taskProof): validate taskProof server-side (here we mark as accepted but store it)
 - Mint tokens using mintTo, record MintLog, update User.tokens_cached
 - Return { success: true, mintSig }
*/
app.post('/api/mine', async (req, res) => {
  try {
    const { userPubkey, amount, paymentTxSig, taskProof } = req.body;
    if (!userPubkey || !amount) return res.status(400).json({ error: 'missing' });
    const amtNum = Number(amount);
    if (isNaN(amtNum) || amtNum <= 0) return res.status(400).json({ error: 'invalid-amount' });

    // prevent abuse: rate-limit by checking last mint logs for wallet in DB (simple)
    const recent = await MintLog.findOne({ where: { wallet: userPubkey }, order: [['createdAt', 'DESC']] });
    if (recent && (Date.now() - new Date(recent.createdAt).getTime()) < 5000) {
      return res.status(429).json({ error: 'too-many-requests' });
    }

    // If payment flow: verify
    let paymentVerified = false;
    let paymentDelta = 0;
    if (paymentTxSig) {
      // price model: use lamports per token env var PRICE_LAMPORTS (default 1e6 = 0.001 SOL)
      const PRICE_LAMPORTS = Number(process.env.PRICE_LAMPORTS ?? 1000000);
      const expectedLamports = PRICE_LAMPORTS * amtNum;
      const verify = await verifyPaymentTx(paymentTxSig, userPubkey, OWNER_SOL.toBase58(), expectedLamports);
      if (!verify.ok) return res.status(400).json({ error: 'payment-verify-failed', reason: verify.reason, delta: verify.delta });
      paymentVerified = true;
      paymentDelta = verify.delta;
    } else {
      // free mining: validate taskProof
      if (!taskProof) return res.status(400).json({ error: 'no-proof' });
      // Example server-side validation: check known module completions or simple checks
      // For demo, accept proof if it has timestamp and mode
      if (!taskProof.timestamp || !taskProof.mode) return res.status(400).json({ error: 'invalid-proof' });
      // Store proof for audit
      await TaskProof.create({ wallet: userPubkey, proof: taskProof });
    }

    // Mint on-chain
    const { sig, mintedSmallest } = await mintTokensToUser(userPubkey, amtNum);

    // Save MintLog
    await MintLog.create({ wallet: userPubkey, amount: mintedSmallest.toString(), mintSig: sig, paymentTxSig: paymentTxSig ?? null, taskProof: taskProof ?? null });

    // Update (or create) user cached balance
    const [user] = await User.findOrCreate({ where: { wallet: userPubkey } });
    const current = BigInt(user.tokens_cached || 0);
    user.tokens_cached = (current + BigInt(mintedSmallest)).toString();
    await user.save();

    res.json({ success: true, mintSig: sig });
  } catch (err) { console.error(err); res.status(500).json({ error: err.message }); }
});

// start
const PORT = process.env.PORT || 4000;
initDb().then(() => {
  app.listen(PORT, () => console.log('WealthForge backend running on', PORT));
}).catch(err => { console.error('DB init failed', err); process.exit(1); });
