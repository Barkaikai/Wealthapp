Excellent â€” you already have a very solid startup sequence.
From the log, your server isnâ€™t crashing, but itâ€™s throwing two avoidable issues:

Duplicate database connection ([DB] Database connection established twice)

The garbage collection (GC) warning

(Optional) The CTRL+C exit (^C) may prevent clean shutdowns

Letâ€™s fix all three with clean, production-ready code.

ğŸ§© 1ï¸âƒ£ Problem: Duplicate DB connection

Youâ€™re calling connectDB() twice â€” once directly and once indirectly (likely from your automation or monitor modules).

âœ… Fix: Use a single shared connection instance

db.js

import { MongoClient } from "mongodb";

let client;
let db;

export async function connectDB() {
  if (db) return db; // âœ… Prevent double connection
  const uri = process.env.MONGO_URL;
  client = new MongoClient(uri);
  await client.connect();
  db = client.db("main");
  console.log("[DB] Database connection established");
  return db;
}

export async function closeDB() {
  if (client) await client.close();
  console.log("[DB] Database connection closed");
}


Now, all modules (automationScheduler, taskQueue, etc.) should import connectDB() from this file â€” never create their own client.

ğŸ§© 2ï¸âƒ£ Problem: Garbage Collection warning

You see this message:

[GC Manager] âš ï¸ Garbage collection not exposed. Start Node with --expose-gc


Node disables manual GC by default for security and stability reasons.
To enable your HealthMonitor to run its memory cleanup, you can safely expose it for development (not production).

âœ… Fix Option 1 (Dev Script)

Create a script file named start-dev.sh:

#!/bin/bash
echo "ğŸ§¹ Starting Node with manual garbage collection enabled..."
NODE_ENV=development node --expose-gc server/index.ts


Then make it executable:

chmod +x start-dev.sh


Now start your app with:

./start-dev.sh

âœ… Fix Option 2 (Permanent NPM script)

If you use npm scripts, edit your package.json:

{
  "scripts": {
    "dev": "NODE_ENV=development node --expose-gc --loader tsx server/index.ts",
    "start": "NODE_ENV=production node --expose-gc --loader tsx server/index.ts"
  }
}


Then just run:

npm run dev

âœ… Fix Option 3 (If you canâ€™t expose GC)

If youâ€™re on a managed host (like Replit) that doesnâ€™t allow --expose-gc, add a fail-safe in your monitor:

// in HealthMonitor.js
if (global.gc) {
  global.gc();
} else {
  console.warn("[GC Manager] GC not available; skipping cleanup safely.");
}


That prevents warnings or crashes.

ğŸ§© 3ï¸âƒ£ Problem: ^C (Unclean shutdown)

When you press CTRL+C, Node stops immediately â€” sometimes without closing DB connections or pending jobs.

âœ… Fix: Graceful shutdown

Add this to your main server file (server/index.ts or server.js):

import { closeDB } from "./db.js";

process.on("SIGINT", async () => {
  console.log("\nğŸ§˜ Gracefully shutting down...");
  await closeDB();
  process.exit(0);
});

process.on("SIGTERM", async () => {
  console.log("\nğŸ§˜ Received termination signal...");
  await closeDB();
  process.exit(0);
});


This ensures your DB connections and schedulers close cleanly.

âœ… Final State (After Fix)
[AppLogger] Initialized
[HealthMonitor] Initialized
[DB] Database connection established
[express] âœ“ Server listening on port 5000
[HealthMonitor] âœ“ GC available
[AutomationScheduler] âœ“ Tasks scheduled
âœ… Server running smoothly with no duplicate DB or GC warnings

ğŸ§  Bonus: Speed Optimization (Optional)

If you still find slow startup due to background jobs:

Move your automation scheduler initialization to run after port open, not before (use setTimeout 2â€“3 seconds after app.listen()).

Example:

app.listen(PORT, () => {
  console.log(`ğŸš€ Server ready on port ${PORT}`);
  setTimeout(initializeBackgroundServices, 3000);
});


That ensures the server starts instantly and handles users right away.