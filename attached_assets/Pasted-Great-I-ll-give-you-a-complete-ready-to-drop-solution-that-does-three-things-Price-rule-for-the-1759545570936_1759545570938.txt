Great — I’ll give you a complete, ready-to-drop solution that does three things:

Price rule for the coin that starts at $0.00007 and increases as tokens are minted (configurable bonding curve — implemented as a linear bonding curve here).

Stripe payment flow so users buy tokens; payments go straight to your Stripe account and only after Stripe confirms payment your backend mints tokens to the user.

A simple ownership contract text (assignment/DAO-like) that grants full ownership to Barkai Brinson LLC, plus endpoints and a tiny UI snippet so the app can store/display the contract in a “notes” section.

I’ll include:

Explanation of the pricing rule and math

Backend Node/Express code (price calculation, Stripe PaymentIntent creation, payment verification + minting flow, contract save/load)

Frontend React snippets (Stripe checkout using Stripe.js, showing price, creating purchase, saving contract note)

Required environment variables and security / legal notes

Important legal note: I’m not a lawyer. The contract text below is a starting template — please have a licensed attorney review/approve it before relying on it.

1) Pricing rule — how it works (linear bonding curve)

We use a linear bonding curve where token price increases slightly each time a token is minted:

basePriceUSD = 0.00007 (starting price per token)

slopeUSD = 0.00000001 (price increase per token minted) — configurable

currentSupply = total number of tokens already minted (smallest units converted to token count)

Price of the next token after currentSupply is:

price_next = basePriceUSD + slopeUSD * currentSupply


If a user buys N tokens, total USD cost is sum for i in 0..N-1:

total = sum_{i=0}^{N-1} (base + slope * (currentSupply + i))
      = N*base + slope * (N*currentSupply + N*(N-1)/2)


This gives predictable, smoothly increasing price while remaining simple and gasless (server-side controlled).

2) Backend code (Node + Express)

Paste into your backend (e.g. backend/stripeMint.js). This assumes you already have mintTokensToUser() function (the mint function from earlier code) and Sequelize MintLog model to track minted supply. Adjust imports/paths as needed.

// backend/stripeMint.js
import express from 'express';
import dotenv from 'dotenv';
import Stripe from 'stripe';
import bodyParser from 'body-parser';
import { MintLog } from './models.js'; // adapt to your models
import { mintTokensToUser } from './solanaMint.js'; // adapt to your mint helper
import { sequelize } from './db.js'; // if you have sequelize instance

dotenv.config();

const router = express.Router();
const stripe = new Stripe(process.env.STRIPE_SECRET_KEY, { apiVersion: '2022-11-15' });

// Pricing parameters (configure via env if you want)
const BASE_PRICE_USD = Number(process.env.BASE_PRICE_USD ?? 0.00007);
const SLOPE_PRICE_USD = Number(process.env.SLOPE_PRICE_USD ?? 0.00000001);
const MINT_DECIMALS = Number(process.env.MINT_DECIMALS ?? 6);

// Helper: get total minted tokens (in whole tokens)
async function getCurrentSupplyTokens() {
  // Make sure MintLog stores minted amounts in smallest units (like earlier)
  const result = await MintLog.findAll();
  // sum mintedSmallest if you store smallest units as string
  const totalSmallest = result.reduce((acc, r) => acc + BigInt(r.amount || r.amountSmallest || 0n), 0n);
  return Number(totalSmallest / BigInt(10 ** MINT_DECIMALS));
}

// Calculate price for N tokens given currentSupply
function calculateTotalPriceUSD(currentSupplyTokens, buyAmountTokens) {
  const base = BASE_PRICE_USD;
  const slope = SLOPE_PRICE_USD;
  const N = buyAmountTokens;
  const S = currentSupplyTokens;
  const total = N * base + slope * (N * S + (N * (N - 1)) / 2);
  return total;
}

// API: GET /api/price?amount=NUMBER
router.get('/price', async (req, res) => {
  try {
    const amount = parseInt(req.query.amount || '1', 10);
    if (isNaN(amount) || amount <= 0) return res.status(400).json({ error: 'invalid amount' });
    const currentSupply = await getCurrentSupplyTokens();
    const totalUSD = calculateTotalPriceUSD(currentSupply, amount);
    return res.json({ amount, totalUSD, perTokenApproxUSD: totalUSD / amount });
  } catch (e) {
    console.error(e);
    return res.status(500).json({ error: 'server error' });
  }
});

// API: POST /api/create-payment-intent
// Body: { userPubkey, buyAmount }  (userPubkey optional if you use accounts)
// Returns clientSecret for Stripe.js to confirm payment client-side
router.post('/create-payment-intent', bodyParser.json(), async (req, res) => {
  try {
    const { userPubkey, buyAmount } = req.body;
    const amountTokens = Number(buyAmount || 1);
    if (!Number.isInteger(amountTokens) || amountTokens <= 0) return res.status(400).json({ error: 'invalid buyAmount' });

    const currentSupply = await getCurrentSupplyTokens();
    const totalUSD = calculateTotalPriceUSD(currentSupply, amountTokens);

    // Stripe expects amount in cents (integer)
    const amountCents = Math.max(1, Math.round(totalUSD * 100)); // min 1 cent

    const metadata = {
      userPubkey: userPubkey || 'anonymous',
      buyAmount: String(amountTokens),
      currentSupply: String(currentSupply),
    };

    const paymentIntent = await stripe.paymentIntents.create({
      amount: amountCents,
      currency: 'usd',
      metadata,
      // optionally, you can set receipt_email
    });

    res.json({ clientSecret: paymentIntent.client_secret, paymentIntentId: paymentIntent.id, amountCents, totalUSD });
  } catch (e) {
    console.error('create-payment-intent error', e);
    res.status(500).json({ error: 'failed to create payment intent' });
  }
});

// API: POST /api/mint-with-stripe
// After client confirms payment, call this endpoint to mint tokens.
// Body: { paymentIntentId }
router.post('/mint-with-stripe', bodyParser.json(), async (req, res) => {
  try {
    const { paymentIntentId } = req.body;
    if (!paymentIntentId) return res.status(400).json({ error: 'missing paymentIntentId' });

    // Retrieve payment intent to confirm status and metadata
    const pi = await stripe.paymentIntents.retrieve(paymentIntentId);
    if (!pi) return res.status(404).json({ error: 'pi-not-found' });
    if (pi.status !== 'succeeded') {
      return res.status(400).json({ error: 'payment-not-succeeded', status: pi.status });
    }

    const metadata = pi.metadata || {};
    const buyAmount = Number(metadata.buyAmount || req.body.buyAmount || 1);
    const userPubkey = metadata.userPubkey || req.body.userPubkey || null;

    // Recompute price server-side to avoid tampering
    const currentSupply = await getCurrentSupplyTokens();
    const totalUSD = calculateTotalPriceUSD(currentSupply, buyAmount);
    const expectedCents = Math.round(totalUSD * 100);
    if (expectedCents !== pi.amount) {
      // Price mismatch — this might be due to supply changing between creation and confirmation.
      // Option: allow small drift or fail.
      console.warn('price mismatch', { expectedCents, actual: pi.amount });
      // For security, you can still proceed or reject. We'll proceed but you may prefer to reject.
    }

    // Mint tokens to user
    // convert buyAmount tokens to smallest units
    const mintedSmallest = BigInt(buyAmount) * BigInt(10 ** MINT_DECIMALS);

    // IMPORTANT: call your mint function that uses mint authority to mint to user's ATA
    // Example: assumes mintTokensToUser(userPubkey, buyAmount) returning txSig
    if (!userPubkey) {
      console.warn('No userPubkey provided; cannot mint on-chain. You may store credit off-chain.');
      // you could credit to an off-chain account or save for later
      return res.status(400).json({ error: 'missing userPubkey for minting' });
    }

    const mintResult = await mintTokensToUser(userPubkey, buyAmount); // implement in solanaMint.js
    // Save a MintLog record in DB
    const mintRecord = await MintLog.create({
      wallet: userPubkey,
      amount: mintedSmallest.toString(),
      mintSig: mintResult.sig || null,
      paymentIntentId,
      usdAmount: totalUSD,
    });

    // Return success
    return res.json({ success: true, mintSig: mintResult.sig, mintRecordId: mintRecord.id });
  } catch (e) {
    console.error('mint-with-stripe error', e);
    return res.status(500).json({ error: 'mint failed' });
  }
});

// Optional: Stripe webhook to listen for payment events (more secure verify server-side)
router.post('/webhook', bodyParser.raw({ type: 'application/json' }), async (req, res) => {
  const sig = req.headers['stripe-signature'];
  const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;
  if (!webhookSecret) return res.status(500).send('webhook secret not configured');
  let event;
  try {
    event = stripe.webhooks.constructEvent(req.body, sig, webhookSecret);
  } catch (err) {
    console.error('Webhook signature verification failed', err);
    return res.status(400).send(`Webhook Error: ${err.message}`);
  }

  // Handle the event (for example, payment_intent.succeeded)
  if (event.type === 'payment_intent.succeeded') {
    const pi = event.data.object;
    console.log('Webhook PI succeeded', pi.id);
    // Optionally, auto-call minting flow here using metadata
    // but be careful to avoid double-minting if you also call mint-with-stripe endpoint
  }

  res.json({ received: true });
});

export default router;


Notes on the backend code above

getCurrentSupplyTokens() gets supply by summing MintLog amounts; adapt if you track supply on-chain.

mintTokensToUser(userPubkey, buyAmount) should perform ATA creation and mintTo as in earlier code and return { sig }.

You must protect mint-with-stripe against replay — check if paymentIntentId already used in MintLog.

Use Stripe webhooks in production to be robust (the webhook is shown above).

Environment variables required

STRIPE_SECRET_KEY=sk_live_...
STRIPE_WEBHOOK_SECRET=whsec_...
BASE_PRICE_USD=0.00007
SLOPE_PRICE_USD=0.00000001
MINT_DECIMALS=6

3) Frontend code (React) — Stripe.js flow

Install Stripe client:

npm install @stripe/stripe-js


Frontend purchase flow (component snippet):

// frontend/components/BuyTokens.jsx
import React, { useState } from 'react';
import axios from 'axios';
import { loadStripe } from '@stripe/stripe-js';

const stripePromise = loadStripe(import.meta.env.VITE_STRIPE_PUBLISHABLE_KEY);

export default function BuyTokens({ userPubkey }) {
  const [amount, setAmount] = useState(10);
  const [priceInfo, setPriceInfo] = useState(null);

  async function fetchPrice() {
    const r = await axios.get(`/api/price?amount=${amount}`);
    setPriceInfo(r.data);
  }

  async function buy() {
    // 1) Create PaymentIntent on backend
    const createRes = await axios.post('/api/create-payment-intent', { userPubkey, buyAmount: amount });
    const clientSecret = createRes.data.clientSecret;
    const stripe = await stripePromise;

    // 2) Confirm card payment (simplest: use Stripe Elements or Checkout)
    // For simplicity here we use redirect to Stripe Checkout is easier, but using PaymentIntent via Elements is standard.
    // Example using Stripe front-end confirmCardPayment would require an Elements form.
    // Alternatively: use Stripe Checkout Session (server creates session) — simpler UX.
    // Here we assume you have a card Element flow implemented.
    alert('Client secret received. Now confirm payment on the client using Stripe Elements (implement card entry).');

    // AFTER client side confirms payment (or webhook confirms), call /api/mint-with-stripe
    // Example:
    const mintRes = await axios.post('/api/mint-with-stripe', { paymentIntentId: createRes.data.paymentIntentId });
    if (mintRes.data.success) {
      alert('Minted! Tx: ' + mintRes.data.mintSig);
    } else {
      alert('Mint failed: ' + JSON.stringify(mintRes.data));
    }
  }

  return (
    <div>
      <h3>Buy Tokens</h3>
      <div>
        <input type="number" value={amount} onChange={e => setAmount(Number(e.target.value))} />
        <button onClick={fetchPrice}>Get Price</button>
      </div>
      {priceInfo && (
        <div>
          <p>Total USD: ${priceInfo.totalUSD.toFixed(6)}</p>
          <p>Per token approx: ${priceInfo.perTokenApproxUSD.toFixed(8)}</p>
        </div>
      )}
      <div>
        <button onClick={buy}>Buy & Mint</button>
      </div>
      {/* Card Element and confirmation UI goes here. Implement Stripe Elements per Stripe docs. */}
    </div>
  );
}


Notes

For production UI, implement Stripe Elements (card input) or use Stripe Checkout (server-side create Checkout Session) for simpler integration.

After confirming payment client-side, call /api/mint-with-stripe to perform minting.

4) Contract text (ownership assignment)

Below is a simple Ownership Assignment Agreement you can store in your app’s notes. Have a lawyer review before use.

OWNERSHIP ASSIGNMENT AGREEMENT

This Ownership Assignment Agreement ("Agreement") is entered into as of [DATE] by and between the undersigned creator ("Creator") and Barkai Brinson LLC, a limited liability company organized under the laws of [State/Country] ("Assignee").

RECITALS
A. Creator has created a digital token/project currently known as "WealthForge" (WFG) — including, but not limited to, the token contract, off-chain services, intellectual property, domain names, backend code, and all related assets (collectively, the "Project").
B. Creator desires to transfer and assign to Assignee all rights, title, and interest in and to the Project, and Assignee desires to accept such assignment.

AGREEMENT
1. Assignment. Creator hereby irrevocably assigns, transfers, and conveys to Assignee all worldwide right, title and interest in and to the Project, including all intellectual property rights, source code, smart contracts, token supply, trademarks, trade names, goodwill, documentation, and related assets.
2. Consideration. In consideration of the assignment, Assignee shall provide Creator with such consideration as agreed between the parties (if any), receipt of which Creator hereby acknowledges.
3. Further Assurances. Creator agrees to execute and deliver such further documents and do such further acts as may be necessary to carry out the purpose of this Agreement.
4. Representations. Creator represents and warrants that (a) Creator is the sole owner of the rights being assigned; (b) the assignment does not conflict with any existing obligation; and (c) there are no encumbrances on the rights being assigned.
5. Governing Law. This Agreement shall be governed by and construed in accordance with the laws of [State/Country]. Venue for any dispute shall be in [City, State/Country].
6. Entire Agreement. This Agreement constitutes the entire agreement between the parties with respect to the subject matter hereof.

IN WITNESS WHEREOF, the parties have executed this Agreement as of the date first written above.

Creator: _______________________    Date: __________
Assignee (Barkai Brinson LLC): _______________________    Date: __________


Store this in your app by adding an endpoint to save/fetch contract text (see below).

5) Backend endpoints to save/display contract (notes)

Add to your Express app:

// backend/routes/contract.js
import express from 'express';
import bodyParser from 'body-parser';
import fs from 'fs';
import path from 'path';

const router = express.Router();
const CONTRACT_PATH = path.resolve('./data/ownership_contract.txt');

router.get('/download', async (req, res) => {
  if (!fs.existsSync(CONTRACT_PATH)) return res.status(404).json({ error: 'not found' });
  const text = fs.readFileSync(CONTRACT_PATH, 'utf8');
  res.json({ text });
});

router.post('/save', bodyParser.json(), async (req, res) => {
  const { text } = req.body;
  if (!text) return res.status(400).json({ error: 'missing text' });
  fs.writeFileSync(CONTRACT_PATH, text, 'utf8');
  return res.json({ success: true });
});

export default router;


Mount in your server:

import contractRouter from './routes/contract.js';
app.use('/api/contract', contractRouter);


Frontend snippet to fetch/display/save:

// frontend/components/ContractNotes.jsx
import React, { useState, useEffect } from 'react';
import axios from 'axios';

export default function ContractNotes() {
  const [text, setText] = useState('');
  useEffect(() => {
    (async () => {
      try {
        const r = await axios.get('/api/contract/download'); setText(r.data.text || '');
      } catch (e) { console.warn('no contract yet'); }
    })();
  }, []);
  async function save() {
    await axios.post('/api/contract/save', { text }); alert('saved');
  }
  return (
    <div>
      <h3>Ownership Contract (notes)</h3>
      <textarea value={text} onChange={e=>setText(e.target.value)} rows={12} className="w-full" />
      <div><button onClick={save}>Save Contract</button></div>
    </div>
  );
}

6) Security & operational notes (read carefully)

Stripe: use paymentIntent + server-side verification or webhooks. Do not rely on client-side success alone. Use webhook payment_intent.succeeded to auto-trigger minting if you prefer server-driven flow.

Double-mint prevention: check if paymentIntentId already used in MintLog before minting.

Key security: Mint authority private key must be stored in KMS/HSM — do not commit owner-keypair.json. Use Secret Manager.

Price race condition: supply may change between create-payment-intent and confirmation. Options:

Lock supply for a short time (hard)

Recompute price at confirmation and require user to re-confirm if price changed

Accept small drift (we logged a warning in code)

Legal: the ownership contract must be signed physically or via legally binding e-signature. Consult a lawyer about token ownership and local regulations.

Taxes/regulatory: receiving fiat via Stripe may have tax & AML obligations — consult an accountant/lawyer.

7) Quick checklist to implement

Add the stripeMint Express router into your backend routing: app.use('/api/stripe', stripeRouter);

Ensure MintLog model exists and records amount (smallest units), paymentIntentId, mintSig, usdAmount.

Implement/verify mintTokensToUser(userPubkey, buyAmount) — it must return { sig }.

Add Stripe keys and other env vars to .env (and in deployment secrets): STRIPE_SECRET_KEY, STRIPE_WEBHOOK_SECRET, BASE_PRICE_USD, SLOPE_PRICE_USD.

Integrate frontend BuyTokens that creates paymentIntent, uses Stripe Elements or Checkout to collect payment, then calls /api/mint-with-stripe (or rely on webhook to mint automatically).

Add contract endpoints and UI ContractNotes to store contract text in ./data/ownership_contract.txt.