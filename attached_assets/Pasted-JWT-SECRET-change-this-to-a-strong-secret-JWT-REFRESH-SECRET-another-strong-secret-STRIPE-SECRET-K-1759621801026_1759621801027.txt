JWT_SECRET=change_this_to_a_strong_secret
JWT_REFRESH_SECRET=another_strong_secret
STRIPE_SECRET_KEY=sk_test_xxx
STRIPE_WEBHOOK_SECRET=whsec_xxx
SMTP_HOST=smtp.example.com
SMTP_PORT=587
SMTP_USER=you@example.com
SMTP_PASS=yourpassword
ADMIN_EMAIL=you@yourdomain.com
APP_BASE_URL=https://your-replit-url.repl.co
Run the setup command in Replit console:

bash
Copy code
npm run setup
Start the server (Replit will do this automatically):

bash
Copy code
npm start
Open the app URL (Replit provides it). Login as the admin via POST /auth/login with the seeded admin credentials printed at setup or use the admin UI link.

Project files
Paste these files into your Replit project. I include only essential files to keep things runnable — you can expand later.

package.json
json
Copy code
{
  "name": "wealthedge-replit",
  "version": "1.0.0",
  "scripts": {
    "build": "tsc",
    "dev": "ts-node-dev --respawn --transpile-only src/server.ts",
    "start": "node dist/server.js",
    "prisma:generate": "prisma generate",
    "prisma:migrate": "prisma migrate deploy",
    "setup": "npm install && npx prisma generate && npx prisma migrate dev --name init --schema=prisma/schema.prisma --skip-seed || true && npm run build"
  },
  "dependencies": {
    "@prisma/client": "^5.0.0",
    "axios": "^1.5.0",
    "bcrypt": "^5.1.0",
    "body-parser": "^1.20.2",
    "bwip-js": "^2.0.10",
    "cookie-parser": "^1.4.6",
    "cors": "^2.8.5",
    "dotenv": "^16.1.4",
    "express": "^4.18.2",
    "jsonwebtoken": "^9.0.0",
    "nodemailer": "^6.9.4",
    "pdfkit": "^0.13.0",
    "prisma": "^5.0.0",
    "stripe": "^12.12.0",
    "uuid": "^9.0.0"
  },
  "devDependencies": {
    "@types/bwip-js": "^1.0.6",
    "@types/cookie-parser": "^1.4.3",
    "@types/express": "^4.17.17",
    "@types/jsonwebtoken": "^9.0.2",
    "@types/node": "^20.4.2",
    "ts-node-dev": "^2.0.0",
    "typescript": "^5.1.6"
  }
}
tsconfig.json
json
Copy code
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "commonjs",
    "outDir": "dist",
    "rootDir": "src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "resolveJsonModule": true
  }
}
.replit
ini
Copy code
language = "nodejs"
run = "bash scripts/deploy-setup.sh && npm run dev"
nix = true

[deployment]
buildCommand = "bash scripts/deploy-setup.sh && npm run build"
runCommand = "npm start"
replit.nix
nix
Copy code
{ pkgs }: {
  deps = [
    pkgs.nodejs-20_x
    pkgs.bash
    pkgs.openssl
    pkgs.git
  ];
}
scripts/deploy-setup.sh
bash
Copy code
#!/usr/bin/env bash
set -e
echo "Setup: installing deps and building"
npm install
npx prisma generate || true
# run migrations (creates SQLite file)
npx prisma migrate dev --name init --skip-seed || true
npm run build || true
echo "Setup complete"
Make it executable in Replit (Replit preserves perms).

prisma/schema.prisma
prisma
Copy code
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL", "file:./dev.db")
}

model User {
  id            String   @id @default(uuid())
  email         String   @unique
  name          String?
  passwordHash  String
  role          Role     @default(USER)
  createdAt     DateTime @default(now())
  refreshTokens RefreshToken[]
  FreePasses    FreePass[] @relation("creator")
}

model RefreshToken {
  id        String   @id @default(uuid())
  token     String   @unique
  user      User     @relation(fields: [userId], references: [id])
  userId    String
  expiresAt DateTime
  createdAt DateTime @default(now())
}

model FreePass {
  id         String   @id @default(uuid())
  code       String   @unique
  createdBy  User     @relation("creator", fields: [createdById], references: [id])
  createdById String
  createdAt  DateTime @default(now())
  redeemedBy User?    @relation(fields: [redeemedById], references: [id])
  redeemedById String?
  redeemedAt DateTime?
  note       String?
}

model SubscriptionConfig {
  id           Int     @id @default(autoincrement())
  stripePriceId String?
  priceCents   Int     @default(2499)
  currency     String  @default("usd")
  updatedAt    DateTime @default(now())
}

model TaxRate {
  id              Int     @id @default(autoincrement())
  regionCode      String  @unique
  stripeTaxRateId String?
  percent         Float?
  updatedAt       DateTime @default(now())
}

enum Role {
  ADMIN
  USER
}
src/server.ts
ts
Copy code
import 'dotenv/config';
import express from 'express';
import bodyParser from 'body-parser';
import cors from 'cors';
import cookieParser from 'cookie-parser';
import { PrismaClient } from '@prisma/client';
import { authRouter } from './routes/auth';
import { adminRouter } from './routes/admin';
import { passesRouter } from './routes/passes';
import { stripeRouter } from './routes/stripe';
import path from 'path';

const prisma = new PrismaClient();
const app = express();
app.use(cors());
app.use(bodyParser.json());
app.use(cookieParser());

// Serve SPA static (frontend build) if exists
app.use(express.static(path.join(__dirname, '../public')));

// API routes
app.use('/api/auth', authRouter(prisma));
app.use('/api/admin', adminRouter(prisma));
app.use('/api/passes', passesRouter(prisma));
app.use('/api/stripe', stripeRouter(prisma));

// health
app.get('/health', (req, res) => res.json({ ok: true }));

// fallback SPA
app.get('*', (req, res) => {
  res.sendFile(path.join(__dirname, '../public/index.html'));
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Server listening on ${PORT}`);
});
src/lib/jwt.ts
ts
Copy code
import jwt from 'jsonwebtoken';
const JWT_SECRET = process.env.JWT_SECRET || 'change_me';
const JWT_REFRESH_SECRET = process.env.JWT_REFRESH_SECRET || 'change_me_refresh';

export function signAccess(payload: object) {
  return jwt.sign(payload, JWT_SECRET, { expiresIn: '15m' });
}
export function signRefresh(payload: object) {
  return jwt.sign(payload, JWT_REFRESH_SECRET, { expiresIn: '30d' });
}
export function verifyAccess(token: string) {
  return jwt.verify(token, JWT_SECRET);
}
export function verifyRefresh(token: string) {
  return jwt.verify(token, JWT_REFRESH_SECRET);
}
src/routes/auth.ts
ts
Copy code
import express from 'express';
import bcrypt from 'bcrypt';
import { PrismaClient, Role } from '@prisma/client';
import { signAccess, signRefresh, verifyRefresh } from '../lib/jwt';
import { v4 as uuidv4 } from 'uuid';

export function authRouter(prisma: PrismaClient) {
  const router = express.Router();

  // Register (admin creates user via admin UI normally)
  router.post('/register', async (req, res) => {
    const { email, password, name } = req.body;
    if (!email || !password) return res.status(400).json({ error: 'missing' });
    const hash = await bcrypt.hash(password, 10);
    const user = await prisma.user.create({ data: { email, passwordHash: hash, name } });
    res.json({ id: user.id });
  });

  // Login
  router.post('/login', async (req, res) => {
    const { email, password } = req.body;
    const user = await prisma.user.findUnique({ where: { email }});
    if (!user) return res.status(401).json({ error: 'invalid' });
    const ok = await bcrypt.compare(password, user.passwordHash);
    if (!ok) return res.status(401).json({ error: 'invalid' });

    const access = signAccess({ sub: user.id, role: user.role });
    const refresh = signRefresh({ sub: user.id });
    await prisma.refreshToken.create({ data: { token: refresh, userId: user.id, expiresAt: new Date(Date.now() + 30*24*3600*1000) }});
    res.json({ access, refresh, user: { id: user.id, email: user.email, role: user.role }});
  });

  // Refresh
  router.post('/refresh', async (req, res) => {
    const { refresh } = req.body;
    try {
      const payload = verifyRefresh(refresh) as any;
      const tokenRow = await prisma.refreshToken.findUnique({ where: { token: refresh }});
      if (!tokenRow) return res.status(401).json({ error: 'invalid' });
      const access = signAccess({ sub: payload.sub });
      res.json({ access });
    } catch (err) {
      return res.status(401).json({ error: 'invalid' });
    }
  });

  // Logout
  router.post('/logout', async (req, res) => {
    const { refresh } = req.body;
    if (refresh) await prisma.refreshToken.deleteMany({ where: { token: refresh }});
    res.json({ ok: true });
  });

  return router;
}
src/middleware/auth.ts
ts
Copy code
import { Request, Response, NextFunction } from 'express';
import { verifyAccess } from '../lib/jwt';
import { PrismaClient } from '@prisma/client';

export async function requireAuth(prisma: PrismaClient, req: Request, res: Response, next: NextFunction) {
  const auth = req.headers.authorization as string | undefined;
  if (!auth?.startsWith('Bearer ')) return res.status(401).json({ error: 'unauth' });
  const token = auth.slice(7);
  try {
    const payload: any = verifyAccess(token) as any;
    // Attach user data
    (req as any).user = { id: payload.sub, role: payload.role };
    // optionally load user from DB
    const user = await prisma.user.findUnique({ where: { id: payload.sub }});
    if (!user) return res.status(401).json({ error: 'no_user' });
    (req as any).user.db = user;
    next();
  } catch (err) {
    return res.status(401).json({ error: 'invalid' });
  }
}
src/routes/admin.ts
ts
Copy code
import express from 'express';
import { PrismaClient } from '@prisma/client';
import { requireAuth } from '../middleware/auth';
import { v4 as uuidv4 } from 'uuid';
import { sendPassEmail } from '../services/email';
import { createPassPdf } from '../services/pdf';
import Stripe from 'stripe';

export function adminRouter(prisma: PrismaClient) {
  const router = express.Router();

  router.use(async (req: any, res, next) => requireAuth(prisma, req, res, next));

  // role guard
  router.use((req: any, res, next) => {
    if (req.user.role !== 'ADMIN') return res.status(403).json({ error: 'forbidden' });
    next();
  });

  // create passes (limit 400)
  router.post('/create-passes', async (req: any, res) => {
    const { count = 1, note, email } = req.body;
    const total = await prisma.freePass.count();
    if (total + count > 400) return res.status(400).json({ error: 'limit' });
    const created = [];
    for (let i=0;i<count;i++){
      const code = uuidv4();
      const pass = await prisma.freePass.create({ data: { code, createdById: req.user.id, note }});
      created.push(pass);
      if (email) {
        // send email with code and PDF
        const pdfBuf = await createPassPdf(code);
        await sendPassEmail(email, code, pdfBuf);
      }
    }
    res.json({ created });
  });

  router.get('/passes', async (req: any, res) => {
    const rows = await prisma.freePass.findMany({ orderBy: { createdAt: 'desc' }});
    res.json(rows);
  });

  // rotate stripe price - create new price and update config
  router.post('/rotate-price', async (req: any, res) => {
    const stripe = new Stripe(process.env.STRIPE_SECRET_KEY || '', { apiVersion: '2024-11-01' });
    const { priceCents, currency = 'usd' } = req.body;
    const product = await stripe.products.create({ name: 'App Monthly Subscription' });
    const price = await stripe.prices.create({
      unit_amount: priceCents,
      currency,
      recurring: { interval: 'month' },
      product: product.id
    });
    await prisma.subscriptionConfig.create({ data: { stripePriceId: price.id, priceCents, currency }});
    res.json({ ok: true, priceId: price.id });
  });

  // open billing portal
  router.post('/billing-portal', async (req: any, res) => {
    const stripe = new Stripe(process.env.STRIPE_SECRET_KEY || '', { apiVersion: '2024-11-01' });
    const { customerId } = req.body;
    if (!customerId) return res.status(400).json({ error: 'customerId required' });
    const session = await stripe.billingPortal.sessions.create({ customer: customerId, return_url: process.env.APP_BASE_URL });
    res.json({ url: session.url });
  });

  return router;
}
src/routes/passes.ts
ts
Copy code
import express from 'express';
import { PrismaClient } from '@prisma/client';
import { requireAuth } from '../middleware/auth';
import { createPassPdf } from '../services/pdf';
import QRCode from 'qrcode';

export function passesRouter(prisma: PrismaClient) {
  const router = express.Router();
  router.use((req:any,res,next)=>requireAuth(prisma, req,res,next));

  router.post('/redeem', async (req:any, res) => {
    const { code } = req.body;
    const pass = await prisma.freePass.findUnique({ where: { code }});
    if (!pass) return res.status(404).json({ error: 'invalid' });
    if (pass.redeemedAt) return res.status(400).json({ error: 'already' });
    await prisma.freePass.update({ where: { code }, data: { redeemedById: req.user.id, redeemedAt: new Date() }});
    res.json({ ok: true });
  });

  router.get('/:code/pdf', async (req, res) => {
    const { code } = req.params;
    // return PDF
    const pdf = await createPassPdf(code);
    res.setHeader('Content-Type', 'application/pdf');
    res.send(pdf);
  });

  router.get('/:code/qrcode', async (req, res) => {
    const { code } = req.params;
    const dataUrl = await QRCode.toDataURL(code);
    res.json({ dataUrl });
  });

  return router;
}
src/services/email.ts
ts
Copy code
import nodemailer from 'nodemailer';

const transporter = nodemailer.createTransport({
  host: process.env.SMTP_HOST,
  port: parseInt(process.env.SMTP_PORT || '587'),
  secure: false,
  auth: {
    user: process.env.SMTP_USER,
    pass: process.env.SMTP_PASS
  }
});

export async function sendPassEmail(to: string, code: string, pdfBuffer?: Buffer) {
  const html = `<p>Your admin has created a free access pass: <b>${code}</b></p><p>Attach or scan the PDF to redeem.</p>`;
  const mail = {
    from: process.env.SMTP_USER,
    to,
    subject: 'Your Free Access Pass',
    html,
    attachments: pdfBuffer ? [{ filename: `${code}.pdf`, content: pdfBuffer }] : []
  };
  return transporter.sendMail(mail);
}
src/services/pdf.ts
ts
Copy code
import PDFDocument from 'pdfkit';
import bwipjs from 'bwip-js';

export async function createPassPdf(code: string): Promise<Buffer> {
  // Generate barcode PNG
  const png = await bwipjs.toBuffer({ bcid: 'qrcode', text: code, scale: 5, includetext: false });
  const doc = new PDFDocument({ size: 'A4' });
  const chunks: any[] = [];
  doc.on('data', (c) => chunks.push(c));
  doc.on('end', () => {});
  doc.fontSize(20).text('Free Access Pass', { align: 'center' });
  doc.moveDown();
  doc.image(png, { fit: [200, 200], align: 'center' });
  doc.moveDown();
  doc.fontSize(14).text(code, { align: 'center' });
  doc.end();
  await new Promise((r) => setTimeout(r, 50));
  return Buffer.concat(chunks);
}
src/routes/stripe.ts
ts
Copy code
import express from 'express';
import { PrismaClient } from '@prisma/client';
import Stripe from 'stripe';
import bodyParser from 'body-parser';

export function stripeRouter(prisma: PrismaClient) {
  const router = express.Router();
  const stripe = new Stripe(process.env.STRIPE_SECRET_KEY || '', { apiVersion: '2024-11-01' });

  router.post('/create-checkout', async (req:any, res) => {
    const { region } = req.body;
    const cfg = await prisma.subscriptionConfig.findFirst({ orderBy: { id: 'desc' }});
    if (!cfg) return res.status(500).json({ error: 'config' });
    let priceId = cfg.stripePriceId;
    // create price if missing
    if (!priceId) {
      const product = await stripe.products.create({ name: 'App Subscription' });
      const price = await stripe.prices.create({ unit_amount: cfg.priceCents, currency: cfg.currency, recurring: { interval: 'month' }, product: product.id });
      priceId = price.id;
      await prisma.subscriptionConfig.updateMany({ where: {}, data: { stripePriceId: priceId }});
    }
    // tax resolution (basic)
    let taxRates: string[] = [];
    if (region) {
      const tr = await prisma.taxRate.findUnique({ where: { regionCode: region }});
      if (tr?.stripeTaxRateId) taxRates.push(tr.stripeTaxRateId);
      else if (tr?.percent) {
        const t = await stripe.taxRates.create({ display_name: `Tax ${region}`, percentage: tr.percent, inclusive: false });
        taxRates.push(t.id);
        await prisma.taxRate.update({ where: { regionCode: region }, data: { stripeTaxRateId: t.id }});
      }
    }

    const session = await stripe.checkout.sessions.create({
      mode: 'subscription',
      line_items: [{ price: priceId, quantity: 1, tax_rates: taxRates }],
      payment_method_types: ['card'],
      success_url: `${process.env.APP_BASE_URL}/billing/success`,
      cancel_url: `${process.env.APP_BASE_URL}/billing/cancel`
    });
    res.json({ url: session.url });
  });

  // webhook
  router.post('/webhook', bodyParser.raw({ type: 'application/json' }), async (req, res) => {
    const sig = req.headers['stripe-signature'] as string | undefined;
    const webhookSecret = process.env.STRIPE_WEBHOOK_SECRET;
    if (!webhookSecret) return res.status(400).send('missing webhook secret');
    try {
      const ev = stripe.webhooks.constructEvent(req.body, sig || '', webhookSecret);
      // handle relevant events (checkout.session.completed etc.)
      if (ev.type === 'checkout.session.completed') {
        const session = ev.data.object as any;
        // you can find the customer and attach to user using metadata (not set in this simple flow)
      }
      res.json({ received: true });
    } catch (err: any) {
      console.error('webhook error', err.message);
      res.status(400).send(`Webhook Error: ${err.message}`);
    }
  });

  return router;
}
public/index.html (simple SPA)
html
Copy code
<!doctype html>
<html>
<head>
  <meta charset="utf-8"/>
  <title>Wealth Automation Platform</title>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <style>body{font-family:Arial,Helvetica,sans-serif;padding:20px}</style>
</head>
<body>
  <h1>Wealth Automation Platform</h1>
  <p>This Replit demo contains admin UI endpoints and a basic frontend.</p>
  <p>Use API endpoints under <code>/api/</code> to interact (Auth, Admin, Passes, Stripe).</p>
  <p>See README for usage.</p>
</body>
</html>
Seeds / Setup actions (done by npm run setup)
Prisma migration will create dev.db SQLite DB with tables.

You should create an admin user (simple script included below) — run once in Replit console:

bash
Copy code
node -e "const bcrypt=require('bcrypt'); const {PrismaClient}=require('@prisma/client'); (async()=>{const p=new PrismaClient(); const pw=await bcrypt.hash('ChangeMe123!',10); const u=await p.user.create({data:{email:process.env.ADMIN_EMAIL||'admin@local',passwordHash:pw,role:'ADMIN'}}); console.log('Admin created',u.id); process.exit();})();"
Store the printed admin id/email; you can then use /api/auth/login to get tokens.

Security & production notes (read before deploying)
Rotate secrets: set strong JWT_SECRET and JWT_REFRESH_SECRET.

SMTP: use a real transactional provider (SendGrid, Mailgun, SES).

Stripe: use real secret in Replit Secrets and set the webhook endpoint: https://<your-replit>/api/stripe/webhook.

HTTPS: Replit provides HTTPS for your URL; ensure APP_BASE_URL uses https.

Rate limit & abuse: add rate-limiting middleware to prevent pass brute-force.

Logging & monitoring: add logging and sentry for errors.

Switch to Postgres in prod: SQLite is fine for testing; use Postgres for production.

