let’s build a fun, user-friendly “mining” coin on Solana that mints on your site and routes any user payments to your personal wallet. Below I’ll provide:

a suggested token name and tokenomics

architecture (how the mining flow works)

full code you can run now (SPL token creation + backend minting + React front-end connecting to Phantom) — minimal viable, production notes and security best practices.

UX ideas and interactive buttons/features to make it playful and educational (wealth/asset building theme).

I’ll assume you want a centralized minting model (backend mints tokens after verifying the user “mined” on your site). That is the simplest, safest, and most practical approach: users perform tasks in the browser → optionally pay a small SOL fee to the owner → backend mints tokens to the user’s token account. The owner holds the mint authority keypair on the server (keep it extremely secure).

1) Token suggestion & tokenomics

Name: WealthForge
Ticker: WFG

Basic tokenomics (example — tweak as you prefer):

Total supply: flexible (mint-on-demand)

Initial circulating: 0; tokens are minted as rewards or sold

Use cases: earned by completing lessons/tasks, bought in small packs, or used to unlock premium lessons / templates / printable assets in your app

Price model (example): 1 WFG per 0.001 SOL (or reward ratio per task)

Owner wallet (receives SOL payments): OWNER_SOL_ADDRESS_HERE (replace when deploying)

2) Architecture (high level)

Create an SPL token (mint) on Solana. Owner retains mint authority private key on a secure server.

Front-end (React) connects to user wallet (Phantom). User clicks “Mine” or completes tasks.

If a paid reward is required: front-end performs a SystemProgram.transfer from user → owner (user signs). Front-end gets the payment transaction signature.

Front-end calls your backend /api/mine endpoint with the user wallet pubkey, the chosen token amount to mint, and (if paid) the payment tx signature and task proof.

Backend verifies: (a) task proof or learning completion, (b) if paid, verifies the payment tx signature and that the recipient was owner and amount correct using a Solana RPC node.

Backend calls mintTo using the mint authority private key (server signs) to mint tokens to the user’s associated token account (creates it if needed). Backend returns success to front-end.

Front-end shows confetti/animation and updates balances.

This design keeps mint authority off the user’s device and avoids writing custom on-chain programs (Anchor/Rust) which are more complex for early prototypes.

3) Implementation — code & commands

Below are runnable examples. Replace placeholders (OWNER_SOL_ADDRESS_HERE, paths, environment variables) before running.

A — Prereqs

Node 18+

npm or yarn

@solana/web3.js and @solana/spl-token packages

A Solana RPC endpoint (Mainnet or Devnet). For development use https://api.devnet.solana.com.

Phantom wallet for browser testing.

B — Create the SPL token (one-time)

You can create the token programmatically or with the SPL Token CLI. Quick Node script to create a mint and save the mint keypair:

// scripts/create_mint.js
import fs from "fs";
import { Keypair, Connection, clusterApiUrl } from "@solana/web3.js";
import { createMint, getOrCreateAssociatedTokenAccount } from "@solana/spl-token";

const RPC = process.env.SOLANA_RPC_URL ?? clusterApiUrl("devnet");
const connection = new Connection(RPC, "confirmed");

// Owner keypair — use a secure keypair and never commit to git
const ownerKeypair = Keypair.fromSecretKey(
  Uint8Array.from(JSON.parse(fs.readFileSync("./owner-keypair.json", "utf-8")))
);

async function main() {
  // Create mint with ownerKeypair as mint authority & freeze authority (optional)
  const decimals = 6; // or 0 — decide decimals
  const mint = await createMint(
    connection,
    ownerKeypair,
    ownerKeypair.publicKey, // mint authority
    null, // freeze authority (optional)
    decimals
  );

  console.log("Created mint:", mint.toBase58());

  // Save mint address somewhere safe (or print)
}

main().catch(console.error);


How to create owner-keypair.json: generate local keypair (be careful—this is the mint authority and must be backed up in a secure HSM/secret manager in production):

node -e "const fs=require('fs'); const {Keypair}=require('@solana/web3.js'); fs.writeFileSync('owner-keypair.json', JSON.stringify(Array.from(Keypair.generate().secretKey)) ); console.log('owner key created');"


Then run:

npm install @solana/web3.js @solana/spl-token
node scripts/create_mint.js


Save the mint address printed (call it MINT_ADDRESS).

C — Backend: Express API to mint on verification

This backend will:

accept /api/mine post: { userPubkey, amount, paymentTxSig (optional), taskProof (optional) }

verify paymentTxSig if present

mint tokens to the user's token account using the owner keypair

Install deps:

npm install express @solana/web3.js @solana/spl-token body-parser dotenv


server.js:

// server.js
import express from "express";
import bodyParser from "body-parser";
import fs from "fs";
import dotenv from "dotenv";
import {
  Connection,
  Keypair,
  PublicKey,
  clusterApiUrl,
  LAMPORTS_PER_SOL,
} from "@solana/web3.js";
import {
  getOrCreateAssociatedTokenAccount,
  mintTo,
  TOKEN_PROGRAM_ID,
} from "@solana/spl-token";

dotenv.config();

const RPC = process.env.SOLANA_RPC_URL ?? clusterApiUrl("devnet");
const connection = new Connection(RPC, "confirmed");

// Load owner keypair (mint authority)
const ownerSecret = JSON.parse(fs.readFileSync("./owner-keypair.json"));
const ownerKeypair = Keypair.fromSecretKey(Uint8Array.from(ownerSecret));

const MINT_ADDRESS = new PublicKey(process.env.MINT_ADDRESS);
const OWNER_SOL = new PublicKey(process.env.OWNER_SOL); // where SOL payments should go

const app = express();
app.use(bodyParser.json());

// Simple helper to verify a payment transaction signature sent by client
async function verifyPaymentTx(txSig, expectedPayer, expectedRecipient, expectedLamports) {
  const tx = await connection.getTransaction(txSig, { commitment: "confirmed" });
  if (!tx) return false;
  // check if there is a SystemProgram transfer instruction matching recipient and amount
  const message = tx.transaction.message;
  // search postBalances / preBalances + account keys to infer transfers
  // Simpler approach: iterate instructions (more robust in production)
  // This simplified check verifies that expectedRecipient received at least expectedLamports
  const postBalances = tx.meta.postBalances;
  const preBalances = tx.meta.preBalances;
  const accountKeys = message.accountKeys.map(k => k.toBase58());
  const idx = accountKeys.indexOf(expectedRecipient.toBase58());
  if (idx === -1) return false;
  const delta = postBalances[idx] - preBalances[idx];
  return delta >= expectedLamports;
}

app.post("/api/mine", async (req, res) => {
  try {
    const { userPubkey, amount, paymentTxSig, taskProof } = req.body;
    const userKey = new PublicKey(userPubkey);
    const amountNumber = Number(amount);
    if (!userKey || !amountNumber) return res.status(400).send({ error: "Bad request" });

    // Example: If paymentTxSig is present, verify it first
    if (paymentTxSig) {
      const expectedLamports = Number(process.env.PRICE_LAMPORTS) * amountNumber; // e.g., per-token price
      const ok = await verifyPaymentTx(paymentTxSig, userKey.toBase58(), OWNER_SOL.toBase58(), expectedLamports);
      if (!ok) return res.status(400).send({ error: "Payment verification failed" });
    } else {
      // If free mining, verify taskProof server-side. Here we accept any truthy taskProof for demo.
      if (!taskProof) {
        return res.status(400).send({ error: "No proof of work provided" });
      }
      // TODO: validate taskProof (e.g., check in DB that user completed lessons)
    }

    // Get or create user's associated token account
    const destATA = await getOrCreateAssociatedTokenAccount(
      connection,
      ownerKeypair, // payer for ATA creation fees (owner pays)
      MINT_ADDRESS,
      userKey
    );

    // Convert amount to smallest units (decimals)
    const decimals = Number(process.env.MINT_DECIMALS ?? 6);
    const mintAmount = BigInt(Math.floor(amountNumber * Math.pow(10, decimals)));

    // Mint tokens to user
    const sig = await mintTo(
      connection,
      ownerKeypair,
      MINT_ADDRESS,
      destATA.address,
      ownerKeypair, // mint authority
      mintAmount
    );

    return res.send({ success: true, mintSig: sig });
  } catch (err) {
    console.error(err);
    return res.status(500).send({ error: err.message });
  }
});

const PORT = process.env.PORT || 4000;
app.listen(PORT, () => console.log("Server running on", PORT));


.env (example):

SOLANA_RPC_URL=https://api.devnet.solana.com
MINT_ADDRESS=PUT_YOUR_MINT_ADDRESS_HERE
OWNER_SOL=PUT_OWNER_SOL_ADDRESS_HERE
PRICE_LAMPORTS=1000000     # 0.001 SOL = 1_000_000 lamports -> price per token example
MINT_DECIMALS=6


Important: the owner-keypair.json file is the mint authority and must be stored securely (never checked into source). In production store in a KMS/HSM and limit access.

D — Front-end (React) — Phantom connect + “Mine” flow

Install:

npx create-react-app wealthforge-ui
cd wealthforge-ui
npm install @solana/web3.js axios


App.js (simplified):

import React, { useEffect, useState } from "react";
import { Connection, PublicKey, clusterApiUrl, SystemProgram, Transaction } from "@solana/web3.js";
import axios from "axios";

const RPC = process.env.REACT_APP_SOLANA_RPC_URL ?? clusterApiUrl("devnet");
const connection = new Connection(RPC, "confirmed");
const OWNER_SOL = process.env.REACT_APP_OWNER_SOL; // same as backend owner
const PRICE_LAMPORTS = Number(process.env.REACT_APP_PRICE_LAMPORTS || 1000000);

function App() {
  const [wallet, setWallet] = useState(null);
  const [balance, setBalance] = useState(0);
  const [status, setStatus] = useState("");

  useEffect(() => {
    (async () => {
      if (window.solana && window.solana.isPhantom) {
        try {
          const resp = await window.solana.connect({ onlyIfTrusted: true });
          setWallet(window.solana);
          const bal = await connection.getBalance(new PublicKey(resp.publicKey.toString()));
          setBalance(bal / 1e9);
        } catch {}
      }
    })();
  }, []);

  async function connectWallet() {
    if (!window.solana) return alert("Install Phantom wallet");
    const resp = await window.solana.connect();
    setWallet(window.solana);
    const bal = await connection.getBalance(new PublicKey(resp.publicKey.toString()));
    setBalance(bal / 1e9);
  }

  // Simulate "task" completion then perform a paid transfer and call backend to mint
  async function minePaidTokens(amountTokens = 10) {
    if (!wallet) return alert("Connect wallet");
    setStatus("Preparing payment...");

    const ownerPub = new PublicKey(OWNER_SOL);
    // build transfer tx
    const lamportsToSend = PRICE_LAMPORTS * amountTokens; // example
    const tx = new Transaction().add(
      SystemProgram.transfer({
        fromPubkey: wallet.publicKey,
        toPubkey: ownerPub,
        lamports: lamportsToSend,
      })
    );

    setStatus("Sending payment (sign in Phantom)...");
    const { signature } = await wallet.signAndSendTransaction(tx);
    setStatus("Payment sent, waiting confirmation...");
    await connection.confirmTransaction(signature, "confirmed");

    setStatus("Requesting mint from backend...");
    // Call backend to mint tokens to this wallet
    const res = await axios.post("/api/mine", {
      userPubkey: wallet.publicKey.toString(),
      amount: amountTokens,
      paymentTxSig: signature,
    });
    if (res.data.success) {
      setStatus(`Minted ${amountTokens} WFG! Tx: ${res.data.mintSig}`);
      // show confetti/animation here
    } else {
      setStatus("Mint failed: " + JSON.stringify(res.data));
    }
  }

  async function mineFreeTokens(amountTokens = 2) {
    // for free tasks: gather proof on client and send to backend
    if (!wallet) return alert("Connect wallet");
    setStatus("Submitting task proof to backend for minting...");
    const taskProof = { lessonId: "lesson-3", timestamp: Date.now(), score: 100 };
    const res = await axios.post("/api/mine", {
      userPubkey: wallet.publicKey.toString(),
      amount: amountTokens,
      taskProof,
    });
    if (res.data.success) {
      setStatus(`Congratulations! You earned ${amountTokens} WFG!`);
    } else {
      setStatus("Mint failed: " + JSON.stringify(res.data));
    }
  }

  return (
    <div style={{ padding: 24 }}>
      <h1>WealthForge (WFG) — Mine & Learn</h1>
      {!wallet ? (
        <button onClick={connectWallet}>Connect Phantom</button>
      ) : (
        <div>
          <p>Connected: {wallet.publicKey.toString()}</p>
          <p>Balance (SOL): {balance}</p>
        </div>
      )}

      <div style={{ marginTop: 20 }}>
        <h3>Interactive mining options</h3>
        <button onClick={() => mineFreeTokens(2)}>Mine 2 WFG (Complete mini lesson)</button>
        <button onClick={() => minePaidTokens(10)} style={{ marginLeft: 12 }}>
          Buy 10 WFG (0.01 SOL) — Quick Pack
        </button>
      </div>

      <div style={{ marginTop: 20 }}>{status}</div>
    </div>
  );
}

export default App;


In production, host the backend domain and set axios base URL accordingly (/api/mine works if backend and frontend are proxied together).