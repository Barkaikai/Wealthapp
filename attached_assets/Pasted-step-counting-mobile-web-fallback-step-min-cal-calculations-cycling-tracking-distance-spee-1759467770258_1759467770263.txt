step counting (mobile + web fallback)

step → min/cal calculations

cycling tracking (distance, speed)

blood pressure & body composition records

health record storage (vitals, meds, history)

mindfulness check-ins, breathing exercises, meditation sessions

sleep logging (bedtime/wake), food logging

stopwatch / stop clock (timers)

automatic sync pipeline (device → app → background worker → AI analyzer)

secure storage and consent reminders

I’ll provide:

a backend (FastAPI + SQLAlchemy) with all endpoints and background sync hooks,

a database schema (models),

background sync worker example (APScheduler or Celery),

AI sync example (how to send data to your app’s AI endpoint),

frontend snippets (React) for camera/stopwatch/breathing/receive steps & upload, and

mobile integration notes (HealthKit / Google Fit) with fallback web code for step counting.

If you want this adapted into a Replit-ready project I can convert these files directly for you — tell me and I’ll prepare a zipped file. For now, here’s a complete, practical implementation you can paste into your project.

1) High-level design

Frontend (React / React Native): collects data from sensors (mobile native APIs / browser fallback), shows UI for breathing exercises / timers, and POSTs events to API.

Backend (FastAPI): REST endpoints for recording events, retrieving history, user config, and triggering AI sync.

DB (Postgres / SQLite): normalized models for users, activities, vitals, sessions, devices, sync logs.

Background worker: scheduled sync jobs that push recent data to AI for analysis and to any third-party sync targets.

Security: JWT auth, HTTPS, encrypted PHI fields (if required), user consent stored.

2) Install (backend)
# create env and install
python -m venv venv
source venv/bin/activate
pip install fastapi uvicorn sqlalchemy alembic pydantic[dotenv] psycopg2-binary python-jose passlib bcrypt requests apscheduler
# Optional: celery + redis if you prefer robust background tasks
pip install celery redis

3) Database models (SQLAlchemy) — models.py
# models.py
from sqlalchemy import Column, Integer, String, DateTime, Float, Boolean, ForeignKey, JSON, Text
from sqlalchemy.orm import relationship, declarative_base
import datetime

Base = declarative_base()

def now():
    return datetime.datetime.utcnow()

class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True)
    email = Column(String(255), unique=True, nullable=False)
    hashed_password = Column(String(255), nullable=False)
    consent_health = Column(Boolean, default=False)
    created_at = Column(DateTime, default=now)

class Device(Base):
    __tablename__ = "devices"
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    device_name = Column(String(255))
    platform = Column(String(50))  # e.g., 'android', 'ios', 'web'
    last_seen = Column(DateTime, default=now)
    user = relationship("User", back_populates="devices")

User.devices = relationship("Device", order_by=Device.id, back_populates="user")

class StepRecord(Base):
    __tablename__ = "steps"
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    device_id = Column(Integer, ForeignKey("devices.id"), nullable=True)
    start_time = Column(DateTime, nullable=False)
    end_time = Column(DateTime, nullable=False)
    steps = Column(Integer, nullable=False)
    distance_m = Column(Float, nullable=True)   # meters
    calories = Column(Float, nullable=True)
    metadata = Column(JSON, default={})
    created_at = Column(DateTime, default=now)

class CycleRecord(Base):
    __tablename__ = "cycles"
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    start_time = Column(DateTime, nullable=False)
    end_time = Column(DateTime, nullable=False)
    distance_m = Column(Float, nullable=True)
    avg_speed_m_s = Column(Float, nullable=True)
    calories = Column(Float, nullable=True)
    device_id = Column(Integer, ForeignKey("devices.id"), nullable=True)
    metadata = Column(JSON, default={})
    created_at = Column(DateTime, default=now)

class VitalRecord(Base):
    __tablename__ = "vitals"
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    recorded_at = Column(DateTime, default=now)
    systolic = Column(Integer, nullable=True)
    diastolic = Column(Integer, nullable=True)
    heart_rate = Column(Integer, nullable=True)
    body_weight_kg = Column(Float, nullable=True)
    body_fat_pct = Column(Float, nullable=True)
    metadata = Column(JSON, default={})

class MindfulnessSession(Base):
    __tablename__ = "mindfulness"
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    started_at = Column(DateTime, nullable=False)
    ended_at = Column(DateTime, nullable=False)
    type = Column(String(100))   # breathing, meditation, checkin
    rating = Column(Integer, nullable=True)  # subjective mood/rating
    metadata = Column(JSON, default={})

class FoodLog(Base):
    __tablename__ = "food_logs"
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    time = Column(DateTime, default=now)
    description = Column(Text)
    calories = Column(Float, nullable=True)
    metadata = Column(JSON, default={})

class SleepLog(Base):
    __tablename__ = "sleep"
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    bedtime = Column(DateTime)
    wake_time = Column(DateTime)
    quality = Column(Integer, nullable=True)  # 1-10
    metadata = Column(JSON, default={})

class SyncLog(Base):
    __tablename__ = "sync_logs"
    id = Column(Integer, primary_key=True)
    user_id = Column(Integer, ForeignKey("users.id"))
    job = Column(String(200))
    started_at = Column(DateTime, default=now)
    finished_at = Column(DateTime, nullable=True)
    status = Column(String(50), default="pending")
    details = Column(JSON, default={})

4) Backend API (FastAPI) — app.py

This includes endpoints to post steps, cycles, vitals, mindfulness, food, sleep, start/stop timers, and trigger AI sync.

# app.py
from fastapi import FastAPI, Depends, HTTPException, BackgroundTasks
from pydantic import BaseModel
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
import os
import datetime
import models  # import the models file above

DATABASE_URL = os.getenv("DATABASE_URL", "sqlite:///./health.db")

engine = create_engine(DATABASE_URL, connect_args={"check_same_thread": False} if "sqlite" in DATABASE_URL else {})
models.Base.metadata.create_all(bind=engine)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

app = FastAPI(title="HealthSync API")

# --- Simple dependencies ---
def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# --- Pydantic schemas ---
class StepIn(BaseModel):
    user_id: int
    device_id: int | None = None
    start_time: datetime.datetime
    end_time: datetime.datetime
    steps: int
    distance_m: float | None = None

class VitalIn(BaseModel):
    user_id: int
    recorded_at: datetime.datetime | None = None
    systolic: int | None = None
    diastolic: int | None = None
    heart_rate: int | None = None
    body_weight_kg: float | None = None
    body_fat_pct: float | None = None

class MindfulIn(BaseModel):
    user_id: int
    started_at: datetime.datetime
    ended_at: datetime.datetime
    type: str
    rating: int | None = None

# --- endpoints ---
@app.post("/api/steps")
def post_steps(payload: StepIn, background_tasks: BackgroundTasks, db: SessionLocal = Depends(get_db)):
    step = models.StepRecord(
        user_id=payload.user_id,
        device_id=payload.device_id,
        start_time=payload.start_time,
        end_time=payload.end_time,
        steps=payload.steps,
        distance_m=payload.distance_m,
        calories=calculate_calories_for_steps(payload.steps, payload.distance_m)
    )
    db.add(step)
    db.commit()
    db.refresh(step)
    # schedule background AI sync for recent steps
    background_tasks.add_task(sync_user_recent_to_ai, payload.user_id, "steps")
    return {"ok": True, "id": step.id}

@app.post("/api/vitals")
def post_vitals(payload: VitalIn, background_tasks: BackgroundTasks, db: SessionLocal = Depends(get_db)):
    v = models.VitalRecord(
        user_id=payload.user_id,
        recorded_at=payload.recorded_at or datetime.datetime.utcnow(),
        systolic=payload.systolic,
        diastolic=payload.diastolic,
        heart_rate=payload.heart_rate,
        body_weight_kg=payload.body_weight_kg,
        body_fat_pct=payload.body_fat_pct
    )
    db.add(v)
    db.commit()
    db.refresh(v)
    background_tasks.add_task(sync_user_recent_to_ai, payload.user_id, "vitals")
    return {"ok": True, "id": v.id}

@app.post("/api/mindfulness")
def post_mindful(payload: MindfulIn, background_tasks: BackgroundTasks, db: SessionLocal = Depends(get_db)):
    s = models.MindfulnessSession(
        user_id=payload.user_id,
        started_at=payload.started_at,
        ended_at=payload.ended_at,
        type=payload.type,
        rating=payload.rating
    )
    db.add(s)
    db.commit()
    db.refresh(s)
    background_tasks.add_task(sync_user_recent_to_ai, payload.user_id, "mindfulness")
    return {"ok": True, "id": s.id}

# other endpoints for /cycle, /food, /sleep would be similar

# --- helper functions ---
def calculate_calories_for_steps(steps:int, distance_m: float | None):
    # rough MET-based approximation: 0.04 kcal per step ~ 0.04*steps
    # optionally use distance and user weight from vitals for better accuracy
    try:
        if distance_m and distance_m>0:
            # average kcal/meter factor: use 1 kcal per 20 meters for an average 70kg person (~0.05 kcal/m)
            return round((distance_m / 20.0), 2)
        return round(0.04 * steps, 2)
    except Exception:
        return None

def sync_user_recent_to_ai(user_id: int, dataset: str):
    """
    Background task to push recent items (last 24h) to AI endpoint for analysis/categorization.
    Example: POST to /ai/analyze with user's new data.
    """
    import requests, json, datetime, os
    db = SessionLocal()
    since = datetime.datetime.utcnow() - datetime.timedelta(hours=24)
    payload = {"user_id": user_id, "dataset": dataset}
    # fetch relevant records
    if dataset == "steps":
        rows = db.query(models.StepRecord).filter(models.StepRecord.user_id==user_id, models.StepRecord.created_at >= since).all()
        payload["items"] = [{"start": r.start_time.isoformat(), "end": r.end_time.isoformat(), "steps": r.steps, "calories": r.calories} for r in rows]
    elif dataset == "vitals":
        rows = db.query(models.VitalRecord).filter(models.VitalRecord.user_id==user_id, models.VitalRecord.recorded_at >= since).all()
        payload["items"] = [{"recorded_at": r.recorded_at.isoformat(), "systolic": r.systolic, "diastolic": r.diastolic, "hr": r.heart_rate} for r in rows]
    elif dataset == "mindfulness":
        rows = db.query(models.MindfulnessSession).filter(models.MindfulnessSession.user_id==user_id, models.MindfulnessSession.started_at >= since).all()
        payload["items"] = [{"start": r.started_at.isoformat(), "end": r.ended_at.isoformat(), "type": r.type, "rating": r.rating} for r in rows]
    else:
        payload["items"] = []

    AI_URL = os.getenv("AI_ANALYZE_URL", "http://localhost:8001/ai/analyze")
    try:
        r = requests.post(AI_URL, json=payload, timeout=10)
        # log sync
        log = models.SyncLog(user_id=user_id, job=f"sync_{dataset}", started_at=datetime.datetime.utcnow(), finished_at=datetime.datetime.utcnow(), status=str(r.status_code), details={"resp": r.text})
    except Exception as e:
        log = models.SyncLog(user_id=user_id, job=f"sync_{dataset}", started_at=datetime.datetime.utcnow(), finished_at=None, status="error", details={"error": str(e)})
    db.add(log); db.commit(); db.close()

5) Background scheduler (automatic sync) — sync_worker.py

If you want periodic sync (push daily/weekly reports / sync with cloud), use APScheduler or Celery.

# sync_worker.py
from apscheduler.schedulers.background import BackgroundScheduler
from datetime import datetime, timedelta
from app import sync_user_recent_to_ai
from models import SessionLocal, User

scheduler = BackgroundScheduler()

def daily_sync():
    db = SessionLocal()
    users = db.query(User).all()
    for u in users:
        # schedule a sync for key datasets
        sync_user_recent_to_ai(u.id, "steps")
        sync_user_recent_to_ai(u.id, "vitals")
        sync_user_recent_to_ai(u.id, "mindfulness")
    db.close()

scheduler.add_job(daily_sync, 'interval', hours=24, next_run_time=datetime.utcnow())
scheduler.start()

# keep process alive if you run this as a standalone worker
if __name__ == "__main__":
    import time
    while True:
        time.sleep(60)


If you prefer Celery + Redis for robust worker queues and retries, replace background_tasks and scheduler with Celery tasks.

6) AI analysis endpoint example (simple) — ai_service.py

Your AI can be a separate service that receives payloads and returns categories, trends, insights.

# ai_service.py (toy example)
from fastapi import FastAPI
from pydantic import BaseModel
from typing import Any
import datetime

app = FastAPI()

class AnalyzeIn(BaseModel):
    user_id: int
    dataset: str
    items: list

@app.post("/ai/analyze")
def analyze_payload(payload: AnalyzeIn):
    # Very simple rule-based logic for demo. Replace with ML/LLM calls later.
    insights = []
    if payload.dataset == "steps":
        total_steps = sum(int(i.get("steps",0)) for i in payload.items)
        insights.append({"metric":"total_steps_24h", "value": total_steps})
        if total_steps < 3000:
            insights.append({"advice":"Try a short walk — small increases compound."})
    if payload.dataset == "vitals":
        for v in payload.items:
            if v.get("systolic") and v["systolic"] > 140:
                insights.append({"alert":"High systolic reading", "value": v})
    return {"insights": insights, "generated_at": datetime.datetime.utcnow().isoformat()}


Later, replace the rule-based logic with an LLM / ML model that receives the JSON and returns categories and suggested actions.

7) Frontend (React) snippets
a) Stopwatch / Stop clock component
// Stopwatch.jsx
import React, {useState, useRef, useEffect} from "react";

export default function Stopwatch({onStop}) {
  const [running, setRunning] = useState(false);
  const [elapsed, setElapsed] = useState(0);
  const startRef = useRef(null);
  useEffect(() => {
    let tid;
    if (running) {
      startRef.current = Date.now() - elapsed;
      tid = setInterval(() => setElapsed(Date.now() - startRef.current, 100), 100);
    }
    return () => clearInterval(tid);
  }, [running]);

  function start() { setRunning(true); }
  function stop() { setRunning(false); onStop && onStop(elapsed); }
  function reset() { setRunning(false); setElapsed(0); }

  return (
    <div>
      <div>{(elapsed/1000).toFixed(1)}s</div>
      <button onClick={start}>Start</button>
      <button onClick={stop}>Stop</button>
      <button onClick={reset}>Reset</button>
    </div>
  );
}

b) Breathing exercise UI
// Breathing.jsx
import React, {useState, useEffect} from "react";

export default function Breathing({inhale=4, hold=4, exhale=6}) {
  const [phase, setPhase] = useState("idle"); // inhale, hold, exhale
  const [secondsLeft, setSecondsLeft] = useState(0);

  useEffect(() => {
    let t;
    if (phase !== "idle") {
      t = setInterval(() => {
        setSecondsLeft(s => {
          if (s <= 1) {
            // advance
            if (phase === "inhale") { setPhase("hold"); return hold; }
            if (phase === "hold") { setPhase("exhale"); return exhale; }
            if (phase === "exhale") { setPhase("inhale"); return inhale; }
          }
          return s-1;
        });
      }, 1000);
    }
    return ()=> clearInterval(t);
  }, [phase]);

  return (
    <div>
      <h3>Breathing</h3>
      <div>Phase: {phase}</div>
      <div>Seconds: {secondsLeft}</div>
      <button onClick={()=>{setPhase("inhale"); setSecondsLeft(inhale);}}>Start</button>
      <button onClick={()=>setPhase("idle")}>Stop</button>
    </div>
  );
}

c) Upload step/cycle to backend (example)
// sendSteps.js
export async function sendSteps(userId, deviceId, startISO, endISO, steps, distance_m=null){
  const res = await fetch("/api/steps", {
    method:"POST", headers:{"Content-Type":"application/json"},
    body: JSON.stringify({
      user_id: userId,
      device_id: deviceId,
      start_time: startISO,
      end_time: endISO,
      steps,
      distance_m
    })
  });
  return res.json();
}

d) Steps from browser (fallback)

Browsers don’t provide native pedometer in most cases. For web, you’ll typically rely on:

Phone native app (React Native) or

Wearable APIs (Google Fit / Apple Health) synced into your app
But you can approximate steps with accelerometer (DeviceMotion) — not as accurate.

Example DeviceMotion (experimental; mobile browsers):

// approxStepCounter.js
let stepCount = 0;
let lastAcc = 0;
let threshold = 1.2; // tune this
window.addEventListener('devicemotion', (ev) => {
  const a = ev.accelerationIncludingGravity;
  if(!a) return;
  const mag = Math.sqrt((a.x||0)**2 + (a.y||0)**2 + (a.z||0)**2);
  const diff = Math.abs(mag - lastAcc);
  if (diff > threshold) stepCount++;
  lastAcc = mag;
});
// periodically send stepCount to backend


This is very rough — use HealthKit / Google Fit for accurate counts.

8) Mobile integration notes (best practices)
i) Apple HealthKit (iOS)

Use HealthKit to read/write steps, distance, sleep, heart rate, body composition, blood pressure (if available).

Implement authorization flow and request only needed scopes (HKQuantityTypeIdentifierStepCount, HKQuantityTypeIdentifierHeartRate, etc.).

Export daily aggregates and push them to your backend via /api/steps etc.

React Native: use react-native-health or @awesome-cordova-plugins/health.

ii) Google Fit (Android)

Use Google Fit REST or SDK to read aggregated steps, calories, cycling, sleep segments.

Get OAuth scopes and periodically push aggregates.

iii) Sync pattern

Device periodically writes a local cache and queues uploads.

Upload strategy:

immediate small events (vitals, BP) → POST right away

aggregated events (steps) → batch every 5–15 minutes or on network availability

if offline → store locally and sync on reconnect (use service worker / background sync on PWA or native background tasks on mobile)

9) Automatic sync to 3rd-party (optional)

Add endpoints and stored user tokens for third-party integrations. Example column in DB: user_tokens table that stores OAuth tokens (encrypted). Background worker uses tokens to POST to Google Fit or your cloud.

10) Privacy, security & compliance

PHI: If you store personal health info, plan for HIPAA compliance if needed (sign BAAs with host).

Encryption: encrypt sensitive DB fields and store only hashed passwords (bcrypt).

Auth: Use OAuth2 / JWT with refresh tokens.

Consent: record user.consent_health and show consent screen before any health data collection.

Data retention: allow users to delete their data and export it.

11) Example flows

A. Simple step flow

Mobile reads steps from HealthKit/Google Fit.

Mobile POST /api/steps with steps aggregate (start/end, steps, distance).

Backend stores StepRecord, calculates calories, triggers background AI sync.

Background worker calls AI /ai/analyze with recent steps → AI returns insights.

Backend stores insights and notifies user (push / in-app).

B. Mindfulness session

User starts breathing UI in React.

When finished, React POST /api/mindfulness with duration, rating.

Backend stores it; AI analyses mood trends and suggests exercises.

12) Extra utilities
calorie estimate helper (more accurate if weight known)
def estimate_calories_walk(steps, weight_kg=70, step_length_m=0.78):
    # calories ~ walking MET ~ 3.5 * weight_kg * time_hours
    # approximate speed -> step_length * steps / time
    distance_km = steps * step_length_m / 1000.0
    # rough calories per km per kg ~ 1 kcal/kg/km
    return round(distance_km * weight_kg * 1.0, 2)